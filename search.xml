<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leedcode</title>
      <link href="2020/12/03/leedcode/"/>
      <url>2020/12/03/leedcode/</url>
      
        <content type="html"><![CDATA[<h1 id="LeedCode"><a href="#LeedCode" class="headerlink" title="LeedCode"></a>LeedCode</h1><p>最近开始复习数据结构与算法，将在LeedCode网站上面进行刷题，将刷题的想法记录下来。这篇文章每天都会更新，所思所想所写放在这里，至于刷题量，每天至少一题，代码实现为Java或者Python。</p><h2 id="2020-12-03（两数之和）"><a href="#2020-12-03（两数之和）" class="headerlink" title="2020.12.03（两数之和）"></a>2020.12.03（两数之和）</h2><pre><code>1.两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。示例:给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><p>看到题目，先分析一波，来个暴力算法，解法枚举数组中的每一个数，然后遍历整个数组找到target-x，代码如下：</p><pre><code>class Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        for (int i = 0; i &lt; nums.length; i++) &#123;            for (int j = i + 1; j &lt; nums.length; j++) &#123;                if (nums[j] == target - nums[i]) &#123;                    return new int[] &#123; i, j &#125;;                &#125;            &#125;        &#125;        throw new IllegalArgumentException(&quot;No two sum solution&quot;);    &#125;&#125;</code></pre><p>可以看到，时间复杂为O($N^2$),思考一下能不能把时间复杂度降下来，O(n)或者O（1）</p><p>其实这个可以用哈希表来解决，用哈希容器map来降低时间复杂度，代码如下：</p><pre><code>class Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();        for(int i = 0; i &lt; nums.length; i++)&#123;            if(map.containsKey(nums[i]))&#123;                return new int[]&#123;map.get(nums[i]), i&#125;;            &#125;            map.put(target - nums[i], i);        &#125;        return null;    &#125;&#125;</code></pre><p>这样就将时间复杂度降到O（n）了</p><h2 id="2020-12-04（两数相加）"><a href="#2020-12-04（两数相加）" class="headerlink" title="2020.12.04（两数相加）"></a>2020.12.04（两数相加）</h2><pre><code>2.两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例：输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></pre><p>看到题目分析一波，这道题是有一点难度的，输入两个链表用逆序的方式储存，所以两个列表中的同一个位置的数是可以相加的，直接遍历两个链表，让同一位置的数值相加，计算他们的和，并与前位置的进位值相加。代码如下</p><pre><code>/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;        ListNode pre = new ListNode(0);        ListNode cur = pre;        int carry = 0;        while(l1 != null || l2 != null) &#123;            int x = l1 == null ? 0 : l1.val;            int y = l2 == null ? 0 : l2.val;            int sum = x + y + carry;            carry = sum / 10;            sum = sum % 10;            cur.next = new ListNode(sum);            cur = cur.next;            if(l1 != null)                l1 = l1.next;            if(l2 != null)                l2 = l2.next;        &#125;        if(carry == 1) &#123;            cur.next = new ListNode(carry);        &#125;        return pre.next;    &#125;&#125;</code></pre><p>有点难度，需要思考一下</p><h2 id="2020-12-05（无重复字符的最长子串）"><a href="#2020-12-05（无重复字符的最长子串）" class="headerlink" title="2020.12.05（无重复字符的最长子串）"></a>2020.12.05（无重复字符的最长子串）</h2><pre><code>3.无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。示例 1:输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。示例 2:输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。示例 3:输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。示例 4:输入: s = &quot;&quot;输出: 0</code></pre><p>老规矩，拿到题目先分析一波，来点大概思路，暴力解法就是直接遍历，但是时间复杂度很高。我们采用滑动窗口，什么是滑动窗口，网上的定义其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！如何移动，我们只要把队列的左边的元素移出就行了，知道满足题目要求！一直维持这样的队列，找出队列出现的最长的长度时候，求出解！Java代码如下：</p><pre><code>class Solution &#123;    public int lengthOfLongestSubstring(String s) &#123;        int n = s.length(), ans = 0;        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();        for (int end = 0, start = 0; end &lt; n; end++) &#123;            char alpha = s.charAt(end);            if (map.containsKey(alpha)) &#123;                start = Math.max(map.get(alpha), start);            &#125;            ans = Math.max(ans, end - start + 1);            map.put(s.charAt(end), end + 1);        &#125;        return ans;    &#125;&#125;</code></pre><p>时间复杂度为为O（n）</p><h2 id="2020-12-06（寻找两个正序数组的中位数）"><a href="#2020-12-06（寻找两个正序数组的中位数）" class="headerlink" title="2020.12.06（寻找两个正序数组的中位数）"></a>2020.12.06（寻找两个正序数组的中位数）</h2><pre><code>4.寻找两个正序数组的中位数给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？ 示例 1：输入：nums1 = [1,3], nums2 = [2]输出：2.00000解释：合并数组 = [1,2,3] ，中位数 2示例 2：输入：nums1 = [1,2], nums2 = [3,4]输出：2.50000解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5示例 3：输入：nums1 = [0,0], nums2 = [0,0]输出：0.00000示例 4：输入：nums1 = [], nums2 = [1]输出：1.00000示例 5：输入：nums1 = [2], nums2 = []输出：2.00000</code></pre><p>分析一波题目，题目要求我们找的是中位数，由于中位数存在两种情况，是奇数的时候取中间，偶数的时候取中间两个数除2。那么可以使用二分查找。Java代码如下：</p><pre><code>class Solution &#123;  public double findMedianSortedArrays(int[] A, int[] B) &#123;    int m = A.length;    int n = B.length;    int len = m + n;    int left = -1, right = -1;    int aStart = 0, bStart = 0;    for (int i = 0; i &lt;= len / 2; i++) &#123;        left = right;        if (aStart &lt; m &amp;&amp; (bStart &gt;= n || A[aStart] &lt; B[bStart])) &#123;            right = A[aStart++];        &#125; else &#123;            right = B[bStart++];        &#125;    &#125;    if ((len &amp; 1) == 0)        return (left + right) / 2.0;    else        return right;  &#125;&#125;</code></pre><p>时间复杂度为O（m+n）</p><p>持续更新中。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leedcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发之基础知识</title>
      <link href="2020/12/01/android-kai-fa-zhi-ji-chu-zhi-shi/"/>
      <url>2020/12/01/android-kai-fa-zhi-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="Android基础知识"><a href="#Android基础知识" class="headerlink" title="Android基础知识"></a>Android基础知识</h1><h2 id="1-Android国内现状"><a href="#1-Android国内现状" class="headerlink" title="1    Android国内现状"></a>1    Android国内现状</h2><p>​        在讲Android之前，我先讲一下关于Android的现状，目前Android系统是世界上市场占有率最高的移动操作系统，在国内人们眼中手机只有两种手机，一个是苹果手机，ios系统，一个就是安卓手机，Android系统，国内手机厂商华为，小米，oppo，vivo，一加算起来也是安卓手机，安卓在国内具有庞大的生态链，所以安卓开发岗位在国内一直在招聘，当然，好的岗位要求也更高。</p><h2 id="2-了解Android"><a href="#2-了解Android" class="headerlink" title="2    了解Android"></a>2    了解Android</h2><h3 id="2-1-Android系统架构"><a href="#2-1-Android系统架构" class="headerlink" title="2.1    Android系统架构"></a>2.1    Android系统架构</h3><p>​        Android大致可以分为四层架构：Linux内核层、系统运行层、应用框架层、应用层。</p><h4 id="2-1-1-Linux内核层"><a href="#2-1-1-Linux内核层" class="headerlink" title="2.1.1    Linux内核层"></a>2.1.1    Linux内核层</h4><p>​        Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供了底层驱动，如显示驱动、音频驱动、蓝牙驱动、wifi驱动等。</p><h4 id="2-1-2-系统运行层"><a href="#2-1-2-系统运行层" class="headerlink" title="2.1.2    系统运行层"></a>2.1.2    系统运行层</h4><p>​        这一层通过一些C/C++库来为Android系统提供了主要的特征。如SQLite库提供了数据库的支持，webkit库提供了浏览器内核等。</p><h4 id="2-1-3-应用框架层"><a href="#2-1-3-应用框架层" class="headerlink" title="2.1.3    应用框架层"></a>2.1.3    应用框架层</h4><p>​        这一层主要提供了构建应用程序时可能使用的各种Api，Android自带的一些核心应用就算使用这些Api完成的。</p><h4 id="2-1-4-应用层"><a href="#2-1-4-应用层" class="headerlink" title="2.1.4    应用层"></a>2.1.4    应用层</h4><p>​        所有在手机上安装的应用程序都是属于这一层的，比如系统自带的联系人，短信等程序，或者是从应用商店下载的手机App，当然，也包括你自己开发的程序。我们学习Android开发也是学习Android应用层的开发。</p><h3 id="2-2-Android版本"><a href="#2-2-Android版本" class="headerlink" title="2.2    Android版本"></a>2.2    Android版本</h3><p>​        2008年9月，谷歌正式发布了Android 1.0系统，这也是Android系统最早的版本。从2008到现在2020已经发布了11个版本，目前最新的是Android 11系统。关于Android版本的历史我们在这里不做过多的描述，有兴趣的同学可以去谷歌去搜索。</p><h3 id="2-3-Android四大组件"><a href="#2-3-Android四大组件" class="headerlink" title="2.3    Android四大组件"></a>2.3    Android四大组件</h3><p>在学习Android之前，肯定听说过Android四大组件，想学好Android开发，必须要学好四大组件。Android系统的四大组件分别是Activity（活动）、Service（服务）、Broadcast Receiver（广播接收器）、Content Provider（内容提供器）。</p><h3 id="2-4-Android五大储存"><a href="#2-4-Android五大储存" class="headerlink" title="2.4    Android五大储存"></a>2.4    Android五大储存</h3><p> SharedPreferences、文件储存 、SQLite数据库存储数据、ContentProvider（内容提供器）、网络存储 。</p><h3 id="2-5-Android六大布局"><a href="#2-5-Android六大布局" class="headerlink" title="2.5    Android六大布局"></a>2.5    Android六大布局</h3><p>在Android程序布局有两种布局，一种是使用XML文件描述界面布局，另一种是在Java代码中通过调用方法进行控制，我们既可以使用任何一种声明界面布局的方式，也可以同时使用两种方式。但是我还是推荐大家尽量使用XML文件声明界面元素布局。</p><p>说了这么多还是说一下六大布局吧，分别是：LinearLayout（线性布局）、FrameLayout（框架布局）、TableLayout（表格布局）、RelativeLayout（ 相对布局）、AbsoluteLayout（绝对布局）、GridLayout（网络布局）。</p><h3 id="2-6-七大生命周期"><a href="#2-6-七大生命周期" class="headerlink" title="2.6    七大生命周期"></a>2.6    七大生命周期</h3><p>onCrate （不可见不可交互）、 onStart （可见不可交互） 、 onResume （可见可交互） 、 onPause （可见不可交互） 、onStop （不可见不可交互） 、 onDestroy （销毁） 、 onRestart （从不可见到可见）。</p><h3 id="2-7-八大基本数据类型"><a href="#2-7-八大基本数据类型" class="headerlink" title="2.7    八大基本数据类型"></a>2.7    八大基本数据类型</h3><p>short （短整型） 、 int（ 整型） 、 long （长整型 ）、 float （浮点型） 、 char （字符型） 、 boolean （布尔型 ）、 byte （字节型）。 </p><h2 id="3-开发工具"><a href="#3-开发工具" class="headerlink" title="3.开发工具"></a>3.开发工具</h2><p>​        工欲善其事，必先利其器，学习Android开发必须要一款好的开发工具，这里我们将使用谷歌官方推荐的IDE工具Android Studio。据我所知，国内Android开发工程师大多使用Idea或者Android Studio，Android本身就算基于Idea开发的工具，但不同的是Idea功能更强大，但也收费。而Android Studio是完全免费，大家不用担心是否付费问题。</p><p>​        关于Android Studio的下载我在这就不过多描述了，如何安装一个软件是一名程序员的基本技能，大家可能会在安装SDK的时候出现一点点问题，这些问题就需要你们自己去谷歌来解决了，相信你们都有解决问题的能力。</p><p>在学习Android开发之前，需要你掌握Java的一点基础知识，不然学起来可能有点吃力。</p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="2020/11/26/ji-suan-ji-wang-luo/"/>
      <url>2020/11/26/ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>正在总结归纳中，敬请期待。。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="2020/11/26/ji-suan-ji-zu-cheng-yuan-li/"/>
      <url>2020/11/26/ji-suan-ji-zu-cheng-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><p>正在总结归纳中，敬请期待。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好，我是任同学</title>
      <link href="2020/11/26/ni-hao-wo-shi-ren-tong-xue/"/>
      <url>2020/11/26/ni-hao-wo-shi-ren-tong-xue/</url>
      
        <content type="html"><![CDATA[<p>Hello，朋友你好，我是任同学，软件工程专业大三在读，毕业不出意外应该是一名软件工程师，很高兴能与你在我的博客相遇，其实一开始写这个博客是在学校做一个课程设计的题目，不知道做什么课题，最后一想还是做博客吧，希望给自己留点东西，方便以后回来的时候自己在看看。关于更新的内容，五花八门，可能什么都有，技术栈，数据库，框架，看过的书，生活感悟，或者恋爱日记（目前单身）等等，记录生活中的点点滴滴，也欢迎和大家一起讨论人生，讨论理想。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 自我介绍 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
